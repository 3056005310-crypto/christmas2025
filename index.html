<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>For You | Christmas Memories</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica', sans-serif; background: radial-gradient(circle at 50% 40%, #1a1020 0%, #000000 90%); }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; padding: 25px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-between; }
        .hud-top { display:flex; justify-content: space-between; width:100%; }
        .hud { pointer-events: auto; background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 12px; padding: 20px; color: #fff; width: 280px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        h2 { margin: 0 0 10px 0; color: #ffd700; font-size: 1.1rem; letter-spacing: 2px; text-transform: uppercase; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:8px; }
        #start-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 2000; backdrop-filter: blur(20px); display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 1s, visibility 1s; }
        .start-btn { background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%); border: none; padding: 18px 60px; color: #333; border-radius: 50px; cursor: pointer; font-size: 20px; font-weight: 900; box-shadow: 0 0 40px rgba(142, 197, 252, 0.4); letter-spacing: 4px; text-transform: uppercase; animation: pulse 2s infinite; }
        @keyframes pulse { 0% {box-shadow: 0 0 0 0 rgba(142,197,252,0.6);} 70% {box-shadow: 0 0 0 20px rgba(0,0,0,0);} 100% {box-shadow: 0 0 0 0 rgba(0,0,0,0);} }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 999; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .spinner { width: 50px; height: 50px; border: 4px solid #333; border-top: 4px solid #ffd700; border-radius: 50%; animation: spin 1s infinite linear; }
        @keyframes spin { 100% {transform: rotate(360deg);} }
        #debug { color:#666; font-size:12px; text-align:right;}
        #video-input { display:none; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } } </script>
</head>
<body>
    <audio id="bgm" loop style="display:none"></audio>
    <div id="loader"><div class="spinner"></div><div style="color:white; margin-top:15px;">LOADING...</div></div>
    <div id="start-overlay">
        <div style="color: #fff; font-size: 20px; margin-bottom: 40px; letter-spacing: 3px;">CHRISTMAS MEMORIES</div>
        <button class="start-btn" onclick="startExperience()">OPEN</button>
    </div>
    <video id="video-input"></video>
    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud">
                <h2>Interaction</h2>
                <div style="font-size: 13px; color: #ccc;">‚úä Fist: Tree | üñê Palm: Scatter | üëå Pinch: View</div>
            </div>
            <div id="debug">AI: <span id="status-track">WAITING</span> | Gest: <span id="status-gest">-</span></div>
        </div>
    </div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        const SHARED_MEMORIES = {
            photos: [
                'https://i.postimg.cc/v8CDFzR2/1aca35e99d3af69a18b824f6025743df.jpg',
                'https://i.postimg.cc/L4GhKTdc/402fc5e4a09e5c81a4cfb731674c3dbc.jpg',
                'https://i.postimg.cc/QNvVGbLw/42c046a85a5b42acfe6c32b256e96b38.jpg',
                'https://i.postimg.cc/y62W4P4z/565ecb3dae75b901ca765ed2220c1110.jpg',
                'https://i.postimg.cc/3rzW5BMP/7d7880f923c410c5e7bc7e304d60cd00.jpg',
                'https://i.postimg.cc/Y2TjK3Kc/9c79cd9c5e9e96f10769a3754e356324.jpg'
            ],
            music: 'https://3056005310-crypto.github.io/christmas2025/bgm.mp3' 
        };

        const CONFIG = { colors: { green: 0x052e16, gold: 0xffeebb, red: 0xd92027 }, count: 1200, treeH: 35, treeR: 14 };
        let scene, camera, renderer, composer, treeGroup, instances = {}, objData = [], magicSystem;
        let photoGroup = new THREE.Group();
        const dummy = new THREE.Object3D();
        const STATE = { mode: 'TREE', zoomIdx: -1, input: {x:0, y:0}, hasHand:false };

        initThree();
        animate(); 
        setTimeout(initMediaPipe, 800);

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); 
            treeGroup = new THREE.Group(); scene.add(treeGroup);
            treeGroup.add(photoGroup);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 500);
            camera.position.set(0, 0, 55); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5; // ‰øÆÊ≠£ÊõùÂÖâÔºöË∞É‰ΩéÊõùÂÖâÂ∫¶
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.2)); // ‰øÆÊ≠£ÊõùÂÖâÔºöÈôç‰ΩéÁéØÂ¢ÉÂÖâ
            const sun = new THREE.DirectionalLight(0xffecd2, 0.6); sun.position.set(20, 20, 50); scene.add(sun);

            const rp = new RenderPass(scene, camera);
            const bp = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.25, 0.4, 0.85); // ‰øÆÊ≠£ÊõùÂÖâÔºöÈôç‰ΩéËæâÂÖâÂº∫Â∫¶
            composer = new EffectComposer(renderer); composer.addPass(rp); composer.addPass(bp);

            buildContent(); buildMagicDust();
            window.addEventListener('resize', onResize);
            document.getElementById('loader').style.display='none';
        }

        function buildContent() {
            const gSphere = new THREE.SphereGeometry(0.7, 16, 16);
            const gBox = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const mGold = new THREE.MeshStandardMaterial({color: CONFIG.colors.gold, metalness: 0.8, roughness: 0.2});
            const mGreen = new THREE.MeshStandardMaterial({color: CONFIG.colors.green, metalness: 0.2, roughness: 0.8});
            createInst(gSphere, mGreen, 500, 'green'); createInst(gSphere, mGold, 250, 'gold');
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(2.5, 0), new THREE.MeshBasicMaterial({color:0xfffae0}));
            star.name='STAR'; star.position.y = CONFIG.treeH/2 + 2; treeGroup.add(star);
        }

        function createInst(geo, mat, count, type) {
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            treeGroup.add(mesh); instances[type] = mesh;
            for(let i=0; i<count; i++) {
                const p = i/count; const y = (p - 0.5) * CONFIG.treeH; const maxR = (1 - p) * CONFIG.treeR * 1.2 + 0.5;
                const r = maxR - Math.random()*1.5; const angle = p * Math.PI * 40;
                objData.push({ mesh: mesh, index: i, type:type, tPos: new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r), sPos: new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*80), cPos: new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*80) });
            }
        }

        function buildMagicDust() {
            const count = 1500; const geo = new THREE.BufferGeometry(); const pos = [], cols = [], speeds = [];
            for(let i=0; i<count; i++) {
                const r = Math.random() * 45 + 5; const theta = Math.random() * Math.PI * 2;
                pos.push(Math.cos(theta)*r, (Math.random()-0.5)*60, Math.sin(theta)*r);
                const c = new THREE.Color().setHSL(Math.random()*0.1 + 0.1, 0.8, 0.6); cols.push(c.r, c.g, c.b); speeds.push(Math.random()*0.5 + 0.1);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3)); geo.setAttribute('speed', new THREE.Float32BufferAttribute(speeds, 1));
            magicSystem = new THREE.Points(geo, new THREE.PointsMaterial({size: 0.4, vertexColors: true, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending}));
            scene.add(magicSystem);
        }

        window.buildPhotos = function(urls) {
            photoGroup.clear(); objData = objData.filter(d=>!d.isPhoto);
            const loader = new THREE.TextureLoader(); loader.setCrossOrigin('anonymous');
            urls.forEach((url, i) => {
                const tex = loader.load(url); tex.colorSpace = THREE.SRGBColorSpace;
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(3, 4.5), new THREE.MeshBasicMaterial({map: tex, side: 2, transparent: false}));
                const p = i/urls.length; const y = (p-0.5)*(CONFIG.treeH-6); const r = (1-p)*CONFIG.treeR + 4; const ang = p*Math.PI*6;
                objData.push({ mesh:mesh, index:i, isPhoto:true, tPos: new THREE.Vector3(Math.cos(ang)*r, y, Math.sin(ang)*r), sPos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, 20), cPos: new THREE.Vector3(0,0,0) });
                photoGroup.add(mesh);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if(STATE.mode !== 'TREE') {
                treeGroup.rotation.y += (STATE.input.x - treeGroup.rotation.y)*0.05;
                treeGroup.rotation.x += (STATE.input.y*0.3 - treeGroup.rotation.x)*0.05;
            } else { treeGroup.rotation.y += 0.005; treeGroup.rotation.x += (0 - treeGroup.rotation.x)*0.05; }

            const camQuat = new THREE.Quaternion(); camera.getWorldQuaternion(camQuat);
            const parentQuat = new THREE.Quaternion();

            objData.forEach(d => {
                let target = (STATE.mode==='ZOOM' && d.isPhoto && d.index===STATE.zoomIdx) ? photoGroup.worldToLocal(new THREE.Vector3(0,0,40)) : (STATE.mode==='TREE' ? d.tPos : d.sPos);
                d.cPos.lerp(target, 0.06);
                if(d.isPhoto) {
                    d.mesh.position.copy(d.cPos);
                    // ‰øÆÊ≠£ÔºöÂº∫Âà∂Âπ≥Ë°å‰∫éÂ±èÂπïÈÄªËæë
                    d.mesh.parent.getWorldQuaternion(parentQuat);
                    d.mesh.quaternion.copy(parentQuat.invert()).multiply(camQuat);
                    if(STATE.mode==='ZOOM' && d.index===STATE.zoomIdx) d.mesh.scale.lerp(new THREE.Vector3(2.5,2.5,2.5), 0.1); else d.mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                } else {
                    dummy.position.copy(d.cPos); 
                    if(STATE.mode!=='TREE') dummy.rotation.set(Date.now()*0.001, 0, 0); else dummy.rotation.set(0,0,0);
                    dummy.updateMatrix(); d.mesh.setMatrixAt(d.index, dummy.matrix);
                }
            });
            Object.values(instances).forEach(i => i.instanceMatrix.needsUpdate = true);
            composer.render();
        }

        async function initMediaPipe() {
            try {
                const vid = document.getElementById('video-input');
                const hands = new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
                hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.5});
                hands.onResults(res => {
                    const trackDOM = document.getElementById('status-track'), gestDOM = document.getElementById('status-gest');
                    if(res.multiHandLandmarks.length) {
                        STATE.hasHand = true; trackDOM.innerText = "ACTIVE"; trackDOM.className = 'stat-on';
                        const lm = res.multiHandLandmarks[0]; let fold=0; [8,12,16,20].forEach(i=>{ if(Math.hypot(lm[i].x-lm[0].x, lm[i].y-lm[0].y)<0.25) fold++; });
                        STATE.input.x = -(lm[9].x - 0.5) * 4; STATE.input.y = (lm[9].y - 0.5) * 4;
                        if(fold>=3) { STATE.mode='TREE'; gestDOM.innerText = "FIST"; }
                        else if(Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y) < 0.05) { if(STATE.mode !== 'ZOOM') { STATE.mode='ZOOM'; STATE.zoomIdx = Math.floor(Math.random()*SHARED_MEMORIES.photos.length); } gestDOM.innerText = "PINCH"; }
                        else { STATE.mode='SCATTER'; gestDOM.innerText = "OPEN"; }
                    } else { STATE.hasHand = false; trackDOM.innerText = "SEARCHING..."; }
                });
                const cam = new Camera(vid, {onFrame:async()=>{await hands.send({image:vid})}, width:480, height:360}); cam.start();
            } catch(e) {}
        }

        window.startExperience = function() {
            document.getElementById('start-overlay').style.display='none';
            const audio = document.getElementById('bgm'); 
            // ‰øÆÊ≠£ÔºöÂ¢ûÂä†Èü≥‰πêÂä†ËΩΩÂºÇÂ∏∏ÊçïËé∑ÔºåÈò≤Ê≠¢ÊåâÈíÆÂ§±Êïà
            if(SHARED_MEMORIES.music) {
                audio.src = SHARED_MEMORIES.music;
                audio.play().catch(() => console.log("Music file not found or blocked."));
            }
            buildPhotos(SHARED_MEMORIES.photos);
        };
        function onResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); }
    </script>
</body>
</html>
